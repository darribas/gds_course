
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Hands-on &#8212; A course on Geographic Data Science</title>
    
  <link rel="stylesheet" href="../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Do-It-Yourself" href="diy_H.html" />
    <link rel="prev" title="Concepts" href="concepts_H.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  
  <h1 class="site-logo" id="site-title">A course on Geographic Data Science</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../overview.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../infrastructure.html">
   Infrastructure
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../assessment.html">
   Assessment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../datasets.html">
   Datasets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bibliography.html">
   Bibliography
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  A - Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bA/concepts_A.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bA/lab_A.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bA/diy_A.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  B - Open Science
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bB/concepts_B.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bB/lab_B.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bB/diy_B.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  C - Spatial Data
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bC/concepts_C.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bC/lab_C.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bC/diy_C.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  D - Mapping Data
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bD/concepts_D.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bD/lab_D.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bD/diy_D.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  E - Spatial Weights
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bE/concepts_E.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bE/lab_E.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bE/diy_E.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  F - ESDA
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bF/concepts_F.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bF/lab_F.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bF/diy_F.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  G - Clustering
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../bG/concepts_G.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bG/lab_G.html">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../bG/diy_G.html">
   Do-It-Yourself
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  H - Points
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="concepts_H.html">
   Concepts
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Hands-on
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="diy_H.html">
   Do-It-Yourself
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/content/bH/lab_H.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/darribas/gds_course/master?urlpath=tree/content/bH/lab_H.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#points">
   Points
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#data">
   Data
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#photographs">
     Photographs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#administrative-areas">
     Administrative areas
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#visualization-of-a-point-pattern">
   Visualization of a Point Pattern
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#one-to-one">
     One-to-one
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#points-meet-polygons">
     Points meet polygons
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#irregular-lattices">
       Irregular lattices
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#regular-lattices-hex-binning">
       Regular lattices: hex-binning
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kernel-density-estimation">
     Kernel Density Estimation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clusters-of-points">
   Clusters of points
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basics">
     Basics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#advanced-plotting">
     Advanced plotting
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="hands-on">
<h1>Hands-on<a class="headerlink" href="#hands-on" title="Permalink to this headline">¶</a></h1>
<div class="section" id="points">
<h2>Points<a class="headerlink" href="#points" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>This is an adapted version, with a bit less content and detail, of the chapter on points by Rey, Arribas-Bel and Wolf (<em>in progress</em>) <a class="bibtex reference internal" href="../bibliography.html#reyabwolf" id="id1">[RABWng]</a>. Check out the full chapter, available for free at:</p>
<blockquote>
<div><p><a class="reference external" href="https://geographicdata.science/book/notebooks/08_point_pattern_analysis.html">https://geographicdata.science/book/notebooks/08_point_pattern_analysis.html</a></p>
</div></blockquote>
</div>
<p>Points are spatial entities that can be understood in two fundamentally different ways. On the one hand, points can be seen as fixed objects in space, which is to say their location is taken as given (<em>exogenous</em>). In this case, analysis of points is very similar to that of other types of spatial data such as polygons and lines. On the other hand, points can be seen as the occurence of an event that could theoretically take place anywhere but only manifests in certain locations. This is the approach we will adopt in the rest of the notebook.</p>
<p>When points are seen as events that could take place in several locations but only happen in a few of them, a collection of such events is called a <em>point pattern</em>. In this case, the location of points is one of the key aspects of interest for analysis. A good example of a point pattern is crime events in a city: they could technically happen in many locations but we usually find crimes are committed only in a handful of them. Point patterns can be <em>marked</em>, if more attributes are provided with the location, or <em>unmarked</em>, if only the coordinates of where the event occured are provided. Continuing the crime example, an unmarked pattern would result if only the location where crimes were committed was used for analysis, while we would be speaking of a marked point pattern if other attributes, such as the type of crime, the extent of the damage, etc. was provided with the location.</p>
<p>Point pattern analysis is thus concerned with the description, statistical characerization, and modeling of point patterns, focusing specially on the generating process that gives rise and explains the observed data. <em>What’s the nature of the distribution of points?</em> <em>Is there any structure we can statistically discern in the way locations are arranged over space?</em> <em>Why do events occur in those places and not in others?</em> These are all questions that point pattern analysis is concerned with.</p>
<p>This notebook aims to be a gentle introduction to working with point patterns in Python. As such, it covers how to read, process and transform point data, as well as several common ways to visualize point patterns.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">contextily</span> <span class="k">as</span> <span class="nn">cx</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">ipywidgets</span> <span class="kn">import</span> <span class="n">interact</span><span class="p">,</span> <span class="n">fixed</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="data">
<h2>Data<a class="headerlink" href="#data" title="Permalink to this headline">¶</a></h2>
<div class="section" id="photographs">
<h3>Photographs<a class="headerlink" href="#photographs" title="Permalink to this headline">¶</a></h3>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>You can read more about the dataset on <a class="reference external" href="https://geographicdata.science/book/data/tokyo/tokyo_cleaning.html">its page at the GDS Book</a> website</p>
</div>
<p>We are going to dip our toes in the lake of point data by looking at a sample of geo-referenced photographs in Tokyo. The dataset comes from the GDS Book <a class="bibtex reference internal" href="../bibliography.html#reyabwolf" id="id2">[RABWng]</a> and contains photographs voluntarily uploaded to the Flickr service.</p>
<p>Let’s read the dataset first:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition-important admonition">
<p class="admonition-title">Important</p>
<p>Make sure you are connected to the internet when you run this cell</p>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read remote file</span>
<span class="n">tokyo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;https://geographicdata.science/book/_downloads/7fb86b605af15b3c9cbd9bfcbead23e9/tokyo_clean.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition-alternative admonition">
<p class="admonition-title">Alternative</p>
<p>Instead of reading the file directly off the web, it is possible to download it manually, store it on your computer, and read it locally. To do that, you can follow these steps:</p>
<ol class="simple">
<li><p>Download the file by right-clicking on <a class="reference external" href="https://geographicdata.science/book/_downloads/7fb86b605af15b3c9cbd9bfcbead23e9/tokyo_clean.csv">this link</a> and saving the file</p></li>
<li><p>Place the file on the <em>same folder as the notebook</em> where you intend to read it</p></li>
<li><p>Replace the code in the cell above by:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tokyo</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;tokyo_clean.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="administrative-areas">
<h3>Administrative areas<a class="headerlink" href="#administrative-areas" title="Permalink to this headline">¶</a></h3>
<p>We will later use administrative areas for aggregation. Let’s load them upfront first. These are provided with the course and available online:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition-important admonition">
<p class="admonition-title">Important</p>
<p>Make sure you are connected to the internet when you run this cell</p>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read the file in</span>
<span class="n">areas</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;https://darribas.org/gds_course/content/data/tokyo_admin_boundaries.geojson&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition-alternative admonition">
<p class="admonition-title">Alternative</p>
<p>Instead of reading the file directly off the web, it is possible to download it manually, store it on your computer, and read it locally. To do that, you can follow these steps:</p>
<ol class="simple">
<li><p>Download the file by right-clicking on <span class="xref myst">this link</span> and saving the file</p></li>
<li><p>Place the file on the <em>same folder as the notebook</em> where you intend to read it</p></li>
<li><p>Replace the code in the cell above by:</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">areas</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;tokyo_admin_boundaries.geojson&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The final bit we need to get out of the way is attaching the administrative area code where a photo is located to each area. This can be done with a GIS operation called “spatial join”.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Click the cell below if you are interested in finding out how it works. In the interest of the narrative of this section, we present it collapsed</p>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tokyo_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> 
                                                             <span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">])</span>
                             <span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokyo</span><span class="p">)</span>
<span class="n">crosswalk</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">tokyo_gdf</span><span class="p">,</span> <span class="n">areas</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">)</span>
<span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;admin_area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">crosswalk</span><span class="p">[</span><span class="s2">&quot;GID_2&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Now we are good to go!</p>
</div>
</div>
<div class="section" id="visualization-of-a-point-pattern">
<h2>Visualization of a Point Pattern<a class="headerlink" href="#visualization-of-a-point-pattern" title="Permalink to this headline">¶</a></h2>
<p>We will spend the rest of this notebook learning different ways to visualize a point pattern. In particular, we will consider to main strategies: one relies on aggregating the points into polygons, while the second one is based on creating continuous surfaces using kernel density estimation.</p>
<div class="section" id="one-to-one">
<h3>One-to-one<a class="headerlink" href="#one-to-one" title="Permalink to this headline">¶</a></h3>
<p>The first approach we review here is the one-to-one approach, where we place a dot on the screen for every point to visualise. In Python, one way to do this is with the <code class="docutils literal notranslate"><span class="pre">scatter</span></code> method in the Pandas visualisation layer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot a dot for every image</span>
<span class="n">tokyo</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:xlabel=&#39;longitude&#39;, ylabel=&#39;latitude&#39;&gt;
</pre></div>
</div>
<img alt="../../_images/lab_H_14_1.png" src="../../_images/lab_H_14_1.png" />
</div>
</div>
<p>However this does not give us much geographical context and, since there are many points, it is hard to see any pattern in areas of high density. Let’s tweak the dot display and add a basemap:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot photographs with smaller, more translucent dots</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> 
                        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
                        <span class="n">s</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                        <span class="n">c</span><span class="o">=</span><span class="s2">&quot;xkcd:bright yellow&quot;</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
                       <span class="p">)</span>
<span class="c1"># remove axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Add dark basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatter</span>
              <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_16_0.png" src="../../_images/lab_H_16_0.png" />
</div>
</div>
</div>
<div class="section" id="points-meet-polygons">
<h3>Points meet polygons<a class="headerlink" href="#points-meet-polygons" title="Permalink to this headline">¶</a></h3>
<p>The approach presented above works until a certain number of points to plot; tweaking dot transparency and size only gets us so far and, at some point, we need to shift the focus. Having learned about visualizing lattice (polygon) data, an option is to “turn” points into polygons and apply techniques like choropleth mapping to visualize their spatial distribution. To do that, we will overlay a polygon layer on top of the point pattern, <em>join</em> the points to the polygons by assigning to each point the polygon where they fall into, and create a choropleth of the counts by polygon.</p>
<p>This approach is intuitive but of course raises the following question: <em>what polygons do we use to aggregate the points?</em> Ideally, we want a boundary delineation that matches as closely as possible the point generating process and partitions the space into areas with a similar internal intensity of points. However, that is usually not the case, no less because one of the main reasons we typically want to visualize the point pattern is to learn about such generating process, so we would typically not know a priori whether a set of polygons match it. If we cannot count on the ideal set of polygons to begin with, we can adopt two more realistic approaches: using a set of pre-existing irregular areas or create a artificial set of regular polygons. Let’s explore both.</p>
<div class="section" id="irregular-lattices">
<h4>Irregular lattices<a class="headerlink" href="#irregular-lattices" title="Permalink to this headline">¶</a></h4>
<p>To exemplify this approach, we will use the administrative areas we have loaded above. Let’s add them to the figure above to get better context (unfold the code if you are interested in seeing exactly how we do this):</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot photographs with smaller, more translucent dots</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s2">&quot;longitude&quot;</span><span class="p">,</span> 
                        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
                        <span class="n">s</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                        <span class="n">c</span><span class="o">=</span><span class="s2">&quot;xkcd:bright yellow&quot;</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
                       <span class="p">)</span>
<span class="c1"># Add administrative boundaries</span>
<span class="n">areas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
           <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
           <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;xkcd:pale lavender&quot;</span>
          <span class="p">)</span>
<span class="c1"># remove axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Add dark basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatter</span>
              <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_19_0.png" src="../../_images/lab_H_19_0.png" />
</div>
</div>
<p>Now we need to know how many photographs each are contains. Our photograph table already contains the area ID, so all we need to do here is counting by area and attaching the count to the <code class="docutils literal notranslate"><span class="pre">areas</span></code> table. We rely here on the <code class="docutils literal notranslate"><span class="pre">groupby</span></code> operator which takes all the photos in the table and “groups” them “by” their administrative ID. Once grouped, we apply the method <code class="docutils literal notranslate"><span class="pre">size</span></code>, which counts how many elements each group has and returns a column indexed on the LSOA code with all the counts as its values. We end by assigning the counts to a newly created column in the <code class="docutils literal notranslate"><span class="pre">areas</span></code> table.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create counts</span>
<span class="n">photos_by_area</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;admin_area&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="c1"># Assign counts into a table of its own </span>
<span class="c1"># and joins it to the areas table</span>
<span class="n">areas</span> <span class="o">=</span> <span class="n">areas</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;photo_count&quot;</span><span class="p">:</span> <span class="n">photos_by_area</span><span class="p">}),</span>
                   <span class="n">on</span><span class="o">=</span><span class="s2">&quot;GID_2&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The lines above have created a new column in our <code class="docutils literal notranslate"><span class="pre">areas</span></code> table that contains the number of photos that have been taken within each of the polygons in the table.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Check out <span class="xref myst">Block D</span> if you need a refresher of choropleth maps</p>
</div>
</div>
<p>At this point, we are ready to map the counts. Technically speaking, this is a choropleth just as we have seen many times before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Plot the equal interval choropleth and add a legend</span>
<span class="n">areas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s1">&#39;photo_count&#39;</span><span class="p">,</span> 
           <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;quantiles&#39;</span><span class="p">,</span> 
           <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
           <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
           <span class="n">legend_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
          <span class="p">)</span>
<span class="c1"># Remove the axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Set the title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantile map of photo counts by administrative boundary&quot;</span><span class="p">)</span>
<span class="c1"># Add dark basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatterNoLabels</span>
              <span class="p">)</span>
<span class="c1"># Draw map</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_23_0.png" src="../../_images/lab_H_23_0.png" />
</div>
</div>
<p>The map above clearly shows a concentration of photos in the centre of Tokyo. However, it is important to remember that the map is showing <em>raw</em> counts of tweets. In the case to photos, as with many other phenomena, it is crucial to keep in mind the “container geography” (see <a class="reference internal" href="../bD/concepts_D.html"><span class="doc std std-doc">Block D</span></a> for a refresher of the term). In this case, different administrative areas have different sizes. Everything else equal, a larger polygon may contain more photos, simply because it covers a larger space. To obtain a more accurate picture of the <em>intensity</em> of photos by area, what we would like to see is a map of the <em>density</em> of photos, not of raw counts. To do this, we can divide the count per polygon by the area of the polygon.</p>
<p>Let’s first calculate the area in Sq. metres of each administrative delineation:</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>Note how we need to convert our polygons into a projected CRS. Same as we did with the <a class="reference internal" href="../bE/diy_E.html#diy-e-jp-cities"><span class="std std-ref">Japanese functional urban areas</span></a>, we use the <a class="reference external" href="http://epsg.io/2459">Japan Plane Rectangular CS XVII system</a></p>
<p>Also, we multiply the area by <code class="docutils literal notranslate"><span class="pre">1e-6</span></code> to express the area in squared Km instead of sw. metres</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">areas</span><span class="p">[</span><span class="s2">&quot;area_sqm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">2459</span><span class="p">)</span><span class="o">.</span><span class="n">area</span> <span class="o">*</span> <span class="mf">1e-6</span>
</pre></div>
</div>
</div>
</div>
<p>And we can add the photo density as well:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">areas</span><span class="p">[</span><span class="s2">&quot;photo_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span><span class="p">[</span><span class="s2">&quot;photo_count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">areas</span><span class="p">[</span><span class="s2">&quot;area_sqm&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>With the density at hand, creating the new choropleth is similar as above (check the code in the expandable):</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Plot the equal interval choropleth and add a legend</span>
<span class="n">areas</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s1">&#39;photo_density&#39;</span><span class="p">,</span> 
           <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;quantiles&#39;</span><span class="p">,</span> 
           <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
           <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
           <span class="n">legend_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;loc&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
          <span class="p">)</span>
<span class="c1"># Remove the axes</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Set the title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantile map of photo density by administrative boundary&quot;</span><span class="p">)</span>
<span class="c1"># Add dark basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatterNoLabels</span>
              <span class="p">)</span>
<span class="c1"># Draw map</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_29_0.png" src="../../_images/lab_H_29_0.png" />
</div>
</div>
<p>The pattern in the raw counts is similar to that of density, but we can see how some peripheral, large areas are “downgraded” when correcting for their size, while some smaller polygons in the centre display a higher value.</p>
</div>
<div class="section" id="regular-lattices-hex-binning">
<h4>Regular lattices: hex-binning<a class="headerlink" href="#regular-lattices-hex-binning" title="Permalink to this headline">¶</a></h4>
<p>Sometimes we either do not have any polygon layer to use or the ones we have are not particularly well suited to aggregate points into them. In these cases, a sensible alternative is to create an artificial topology of polygons that we can use to aggregate points. There are several ways to do this but the most common one is to create a grid of hexagons. This provides a regular topology (every polygon is of the same size and shape) that, unlike circles, cleanly exhausts all the space without overlaps and has more edges than squares, which alleviates edge problems.</p>
<p>Python has a simplified way to create this hexagon layer <em>and</em> aggregate points into it in one shot thanks to the method <code class="docutils literal notranslate"><span class="pre">hexbin</span></code>, which is available in every axis object (e.g. <code class="docutils literal notranslate"><span class="pre">ax</span></code>). Let us first see how you could create a map of the hexagon layer alone:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1"># Add hexagon layer that displays count of points in each polygon</span>
<span class="n">hb</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hexbin</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> 
               <span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span> 
               <span class="n">gridsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
              <span class="p">)</span>
<span class="c1"># Add a colorbar (optional)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.colorbar.Colorbar at 0x7f0f11fdb2d0&gt;
</pre></div>
</div>
<img alt="../../_images/lab_H_32_1.png" src="../../_images/lab_H_32_1.png" />
</div>
</div>
<p>See how all it takes is to set up the figure and call <code class="docutils literal notranslate"><span class="pre">hexbin</span></code> directly using the set of coordinate columns (<code class="docutils literal notranslate"><span class="pre">tokyo[&quot;longitude&quot;]</span></code> and <code class="docutils literal notranslate"><span class="pre">tokyo[&quot;latitude&quot;]</span></code>). Additional arguments we include is the number of hexagons by axis (<code class="docutils literal notranslate"><span class="pre">gridsize</span></code>, 50 for a 50 by 50 layer), and the transparency we want (80%). Additionally, we include a colorbar to get a sense of how counts are mapped to colors. Note that we need to pass the name of the object that includes the <code class="docutils literal notranslate"><span class="pre">hexbin</span></code> (<code class="docutils literal notranslate"><span class="pre">hb</span></code> in our case), but keep in mind this is optional, you do not need to always create one.</p>
<p>Once we know the basics, we can dress it up a bit more for better results (expand to see code):</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="c1"># Add hexagon layer that displays count of points in each polygon</span>
<span class="n">hb</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">hexbin</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> 
               <span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span> 
               <span class="n">gridsize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;none&quot;</span>
              <span class="p">)</span>
<span class="c1"># Add a colorbar (optional)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span>
<span class="c1"># Remove axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Add basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatterNoLabels</span>
              <span class="p">)</span>
<span class="c1"># Add title of the map</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Hex-binning of photos in Tokyo&quot;</span><span class="p">)</span>
<span class="c1"># Draw map</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_34_0.png" src="../../_images/lab_H_34_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="kernel-density-estimation">
<h3>Kernel Density Estimation<a class="headerlink" href="#kernel-density-estimation" title="Permalink to this headline">¶</a></h3>
<p>Using a hexagonal binning can be a quick solution when we do not have a good polygon layer to overlay the points directly and some of its properties, such as the equal size of each polygon, can help alleviate some of the problems with a “bad” irregular topology (one that does not fit the underlying point generating process). However, it does not get around the issue of the modifiable areal unit problem (M.A.U.P., see <a class="reference internal" href="../bD/concepts_D.html"><span class="doc std std-doc">Block D</span></a>: at the end of the day, we are still imposing arbitrary boundary lines and aggregating based on them, so the possibility of mismatch with the underlying distribution of the point pattern is very real.</p>
<p>One way to work around this problem is to avoid aggregating into another geography altogether. Instead, we can aim at estimating the <em>continuous</em> observed probability distribution. The most commonly used method to do this is the so called <em>kernel density estimate</em> (KDE). The idea behind KDEs is to count the number of points in a <em>continious</em> way. Instead of using discrete counting, where you include a point in the count if it is inside a certain boundary and ignore it otherwise, KDEs use functions (kernels) that include points but give different weights to each one depending of how far of the location where we are counting the point is.</p>
<p>The actual algorithm to estimate a kernel density is not trivial but its application in Python is rather simplified by the use of Seaborn. KDE’s however are fairly computationally intensive. When you have a large point pattern like we do in the <code class="docutils literal notranslate"><span class="pre">tokyo</span></code> example (10,000 points), its computation can take a bit long. To get around this issue, we create a random subset, which retains the overall structure of the pattern, but with much fewer points. Let’s take a subset of 1,000 random points from our original table:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Take a random subset of 1,000 rows from `tokyo`</span>
<span class="n">tokyo_sub</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">12345</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note we need to specify the size of the resulting subset (1,000), and we also add a value for <code class="docutils literal notranslate"><span class="pre">random_state</span></code>; this ensures that the sample is always the same and results are thus reproducible.</p>
<p>Same as above, let us first see how to create a quick KDE. For this we rely on Seaborn’s <code class="docutils literal notranslate"><span class="pre">kdeplot</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">tokyo_sub</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> 
            <span class="n">tokyo_sub</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span> 
            <span class="n">n_levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
            <span class="n">shade</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;BuPu&#39;</span>
           <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:xlabel=&#39;longitude&#39;, ylabel=&#39;latitude&#39;&gt;
</pre></div>
</div>
<img alt="../../_images/lab_H_38_1.png" src="../../_images/lab_H_38_1.png" />
</div>
</div>
<p>Seaborn greatly streamlines the process and boils it down to a single line. The method <code class="docutils literal notranslate"><span class="pre">sns.kdeplot</span></code> (which we can also use to create a KDE of a single variable) takes the X and Y coordinate of the points as the only compulsory attributes. In addition, we specify the number of levels we want the color gradient to have (<code class="docutils literal notranslate"><span class="pre">n_levels</span></code>), whether we want to color the space in between each level (<code class="docutils literal notranslate"><span class="pre">share</span></code>, yes), and the colormap of choice.</p>
<p>Once we know how the basic logic works, we can insert it into the usual mapping machinery to create a more complete plot. The main difference here is that we now have to tell <code class="docutils literal notranslate"><span class="pre">sns.kdeplot</span></code> where we want the surface to be added (<code class="docutils literal notranslate"><span class="pre">ax</span></code> in this case). Toggle the expandable to find out the code that produces the figure below:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="c1"># Add KDE layer that displays probability surface</span>
<span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span><span class="n">tokyo_sub</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span> 
            <span class="n">tokyo_sub</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span> 
            <span class="n">n_levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> 
            <span class="n">shade</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span>
           <span class="p">)</span>
<span class="c1"># Remove axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
<span class="c1"># Add basemap</span>
<span class="n">cx</span><span class="o">.</span><span class="n">add_basemap</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> 
               <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span>
               <span class="n">source</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">providers</span><span class="o">.</span><span class="n">CartoDB</span><span class="o">.</span><span class="n">DarkMatterNoLabels</span>
              <span class="p">)</span>
<span class="c1"># Add title of the map</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;KDE of photos in Tokyo&quot;</span><span class="p">)</span>
<span class="c1"># Draw map</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_40_0.png" src="../../_images/lab_H_40_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="clusters-of-points">
<h2>Clusters of points<a class="headerlink" href="#clusters-of-points" title="Permalink to this headline">¶</a></h2>
<p>In this final section, we will learn a method to identify clusters of points, based on their density across space. To do this, we will use the widely used <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code> algorithm. For this method, a cluster is a concentration of at least <code class="docutils literal notranslate"><span class="pre">m</span></code> points, each of them within a distance of <code class="docutils literal notranslate"><span class="pre">r</span></code> of at least another point in the cluster. Points in the dataset are then divided into three categories:</p>
<ul class="simple">
<li><p><em>Noise</em>, for those points outside a cluster.</p></li>
<li><p><em>Cores</em>, for those points inside a cluster whith at least <code class="docutils literal notranslate"><span class="pre">m</span></code> points in the cluster within distance <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p></li>
<li><p><em>Borders</em> for points inside a cluster with less than <code class="docutils literal notranslate"><span class="pre">m</span></code> other points in the cluster within distance <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p></li>
</ul>
<p>Both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code> need to be prespecified by the user before running <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code>. This is a critical point, as their value can influence significantly the final result. Before exploring this in greater depth, let us get a first run at computing <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code> in Python.</p>
<div class="section" id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h3>
<p>The heavy lifting is done by the method <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code>, part of the excellent machine learning library <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>. Running the algorithm is similar to how we ran K-Means when <a class="reference internal" href="../bG/lab_G.html"><span class="doc std std-doc">clustering</span></a>. We first set up the details:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up algorithm</span>
<span class="n">algo</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_margin docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Express points in metres</span>
<span class="c1"># Convert lon/lat into Point objects + set CRS</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;longitude&quot;</span><span class="p">],</span>
                         <span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;latitude&quot;</span><span class="p">],</span>
                         <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span>
                        <span class="p">)</span>
<span class="c1"># Convert lon/lat points to Japanese CRS in metres</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">pts</span><span class="p">})</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">2459</span><span class="p">)</span>
<span class="c1"># Extract coordinates from point objects into columns</span>
<span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;X_metres&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
<span class="n">tokyo</span><span class="p">[</span><span class="s2">&quot;Y_metres&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>
</pre></div>
</div>
</div>
</div>
<p>We decide to consider a cluster photos with more than 50 photos within 100 metres from them, hence we set the two parameters accordingly. Once ready, we <em>“fit”</em> it to our data, but note that we first need to express the longitude and latitude of our points in metres (see code for that on the side cell).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">algo</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[[</span><span class="s2">&quot;X_metres&quot;</span><span class="p">,</span> <span class="s2">&quot;Y_metres&quot;</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DBSCAN(eps=100, min_samples=50)
</pre></div>
</div>
</div>
</div>
<p>Once fit, we can recover the labels:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">algo</span><span class="o">.</span><span class="n">labels_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-1, -1, -1, ...,  8, -1, -1])
</pre></div>
</div>
</div>
</div>
<p>And the list of points classified as cores:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Print only the first five values</span>
<span class="n">algo</span><span class="o">.</span><span class="n">core_sample_indices_</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([12, 25, 28, 46, 63])
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">labels_</span></code> object always has the same length as the number of points used to run <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code>. Each value represents the index of the cluster a point belongs to. If the point is classified as <em>noise</em>, it receives a -1. Above, we can see that the first five points are effectively not part of any cluster. To make thinks easier later on, let us turn the labels into a <code class="docutils literal notranslate"><span class="pre">Series</span></code> object that we can index in the same way as our collection of points:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lbls</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">algo</span><span class="o">.</span><span class="n">labels_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we already have the clusters, we can proceed to visualize them. There are many ways in which this can be done. We will start just by coloring points in a cluster in red and noise in grey:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Assign labels to tokyo table dynamically and</span>
<span class="c1"># subset points that are not part of any cluster (noise)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">lbls</span><span class="o">=</span><span class="n">lbls</span><span class="p">)</span>\
             <span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;lbls == -1&quot;</span><span class="p">)</span>
<span class="c1"># Plot noise in grey</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="s2">&quot;X_metres&quot;</span><span class="p">],</span> 
           <span class="n">noise</span><span class="p">[</span><span class="s2">&quot;Y_metres&quot;</span><span class="p">],</span> 
           <span class="n">c</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> 
           <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
           <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span>
          <span class="p">)</span>
<span class="c1"># Plot all points that are not noise in red</span>
<span class="c1"># NOTE how this is done through some fancy indexing, where</span>
<span class="c1">#      we take the index of all points (tw) and substract from</span>
<span class="c1">#      it the index of those that are noise</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tokyo</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> 
                     <span class="s2">&quot;X_metres&quot;</span>
                    <span class="p">],</span> 
           <span class="n">tokyo</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> 
                     <span class="s2">&quot;Y_metres&quot;</span>
                    <span class="p">],</span>
           <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> 
           <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span>
          <span class="p">)</span>
<span class="c1"># Display the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_53_0.png" src="../../_images/lab_H_53_0.png" />
</div>
</div>
<p>This is a first good pass. The algorithm is able to identify a few clusters with high density of photos. However, as we mentioned <a class="reference internal" href="concepts_H.html#concepts-h-dbscan"><span class="std std-ref">when discussing DBSCAN</span></a>, this is all contingent on the parameters we arbitrarily set. Depending on the maximum radious (<code class="docutils literal notranslate"><span class="pre">eps</span></code>) we set, we will pick one type of cluster or another: a higher (lower) radious will translate in less (more) local clusters. Equally, the minimum number of points required for a cluster (<code class="docutils literal notranslate"><span class="pre">min_samples</span></code>) will affect the implicit size of the cluster. Both parameters need to be set before running the algorithm, so our decision will affect the final outcome quite significantly.</p>
<p>For an illustration of this, let’s run through a case with very different parameter values. For example, let’s pick a larger radious (e.g. 500m) and a smaller number of points (e.g. 10):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up algorithm</span>
<span class="n">algo</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># Fit to Tokyo projected points</span>
<span class="n">algo</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tokyo</span><span class="p">[[</span><span class="s2">&quot;X_metres&quot;</span><span class="p">,</span> <span class="s2">&quot;Y_metres&quot;</span><span class="p">]])</span>
<span class="c1"># Store labels</span>
<span class="n">lbls</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">algo</span><span class="o">.</span><span class="n">labels_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And let’s now visualise the result (toggle the expandable to see the code):</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup figure and axis</span>
<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># Assign labels to tokyo table dynamically and</span>
<span class="c1"># subset points that are not part of any cluster (noise)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">tokyo</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">lbls</span><span class="o">=</span><span class="n">lbls</span><span class="p">)</span>\
             <span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;lbls == -1&quot;</span><span class="p">)</span>
<span class="c1"># Plot noise in grey</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="s2">&quot;X_metres&quot;</span><span class="p">],</span> 
           <span class="n">noise</span><span class="p">[</span><span class="s2">&quot;Y_metres&quot;</span><span class="p">],</span> 
           <span class="n">c</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> 
           <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> 
           <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span>
          <span class="p">)</span>
<span class="c1"># Plot all points that are not noise in red</span>
<span class="c1"># NOTE how this is done through some fancy indexing, where</span>
<span class="c1">#      we take the index of all points (tw) and substract from</span>
<span class="c1">#      it the index of those that are noise</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tokyo</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> 
                     <span class="s2">&quot;X_metres&quot;</span>
                    <span class="p">],</span> 
           <span class="n">tokyo</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tokyo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> 
                     <span class="s2">&quot;Y_metres&quot;</span>
                    <span class="p">],</span>
           <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> 
           <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span>
          <span class="p">)</span>
<span class="c1"># Display the figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_57_0.png" src="../../_images/lab_H_57_0.png" />
</div>
</div>
<p>The output is now very different, isn’t it? This exemplifies how different parameters can give rise to substantially different outcomes, even if the same data and algorithm are applied.</p>
</div>
<div class="section" id="advanced-plotting">
<h3>Advanced plotting<a class="headerlink" href="#advanced-plotting" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please keep in mind this final section of the tutorial is <strong>OPTIONAL</strong>, so do not feel forced to complete it. This will not be covered in the assignment and you will still be able to get a good mark without completing it (also, including any of the following in the assignment does NOT guarantee a better mark).</p>
</div>
<p>As we have seen, the choice of parameters plays a crucial role in the number, shape and type of clusters founds in a dataset. To allow an easier exploration of these effects, in this section we will turn the computation and visualization of <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code> outputs into a single function. This in turn will allow us to build an interactive tool later on.</p>
<p>Below is a function that accomplishes just that:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clusters</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute and visualize DBSCAN clusters    </span>
<span class="sd">    ...</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    db          : (Geo)DataFrame</span>
<span class="sd">                  Table with at least columns `X` and `Y` for point coordinates</span>
<span class="sd">    eps         : float</span>
<span class="sd">                  Maximum radious to search for points within a cluster</span>
<span class="sd">    min_samples : int</span>
<span class="sd">                  Minimum number of points in a cluster</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">algo</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">)</span>
    <span class="n">algo</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">db</span><span class="p">[[</span><span class="s1">&#39;X_metres&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_metres&#39;</span><span class="p">]])</span>
    <span class="n">lbls</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">algo</span><span class="o">.</span><span class="n">labels_</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">lbls</span><span class="o">==-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X_metres&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_metres&#39;</span><span class="p">]]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">noise</span><span class="p">[</span><span class="s1">&#39;X_metres&#39;</span><span class="p">],</span> <span class="n">noise</span><span class="p">[</span><span class="s1">&#39;Y_metres&#39;</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="s1">&#39;X_metres&#39;</span><span class="p">],</span> \
               <span class="n">db</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="s1">&#39;Y_metres&#39;</span><span class="p">],</span> \
              <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The function takes the following three arguments:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">db</span></code>: a <code class="docutils literal notranslate"><span class="pre">(Geo)DataFrame</span></code> containing the points on which we will try to find the clusters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eps</span></code>: a number (maybe with decimals, hence the <code class="docutils literal notranslate"><span class="pre">float</span></code> label in the documentation of the function) specifying the maximum distance to look for neighbors that will be part of a cluster.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_samples</span></code>: a count of the minimum number of points required to form a cluster.</p></li>
</ol>
<p>Let us see how the function can be used. For example, let us replicate the plot above, with a minimum of 10 points and a maximum radious of 500 metres:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clusters</span><span class="p">(</span><span class="n">tokyo</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/lab_H_61_0.png" src="../../_images/lab_H_61_0.png" />
</div>
</div>
<p>Voila! With just one line of code, we can create a map of <code class="docutils literal notranslate"><span class="pre">DBSCAN</span></code> clusters. How cool is that?</p>
<p>However, this could be even more interesting if we didn’t have to write each time the parameters we want to explore. To change that, we can create a quick interactive tool that will allow us to modify both parameters with sliders. To do this, we will use the library <a class="reference external" href="https://ipywidgets.readthedocs.io"><code class="docutils literal notranslate"><span class="pre">ipywidgets</span></code></a>. Let us first do it and then we will analyse it bit by bit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">interact</span><span class="p">(</span>
    <span class="n">clusters</span><span class="p">,</span>                 <span class="c1"># Method to make interactive</span>
    <span class="n">db</span><span class="o">=</span><span class="n">fixed</span><span class="p">(</span><span class="n">tokyo</span><span class="p">),</span>          <span class="c1"># Data to pass on db (does not change)</span>
    <span class="n">eps</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>        <span class="c1"># Range start/end/step of eps</span>
    <span class="n">min_samples</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="c1"># Range start/end/step of min_samples</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "cfe7a7d3b1b3409396084074bfcf78af", "version_major": 2, "version_minor": 0}
</script></div>
</div>
<p>Phew! That is cool, isn’t it? Once passed the first excitement, let us have a look at how we built it, and how you can modify it further on. A few points on this:</p>
<ul class="simple">
<li><p>First, <code class="docutils literal notranslate"><span class="pre">interact</span></code> is a method that allows us to pass an arbitrary function (like <code class="docutils literal notranslate"><span class="pre">clusters</span></code>) and turn it into an interactive widget where we modify the values of its parameters through sliders, drop-down menus, etc.</p></li>
<li><p>What we need to pass to <code class="docutils literal notranslate"><span class="pre">interact</span></code> is the name of the function we would like to make interactive (<code class="docutils literal notranslate"><span class="pre">clusters</span></code> in this case), and all the parameters it will take.</p></li>
<li><p>Since in this case we do not wish to modify the dataset that is used, we pass <code class="docutils literal notranslate"><span class="pre">tokyo</span></code> as the <code class="docutils literal notranslate"><span class="pre">db</span></code> argument in <code class="docutils literal notranslate"><span class="pre">clusters</span></code> and fixate it by passing it first to the <code class="docutils literal notranslate"><span class="pre">fixed</span></code> method.</p></li>
<li><p>Then both the radious <code class="docutils literal notranslate"><span class="pre">eps</span></code> and the minimum cluster size <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> are passed. In this case, we do want to allow interactivity, so we do not use <code class="docutils literal notranslate"><span class="pre">fixed</span></code>. Instead, we pass a tuple that specifies the range and the step of the values we will allow to be used.</p></li>
<li><p>In the case of <code class="docutils literal notranslate"><span class="pre">eps</span></code>, we use <code class="docutils literal notranslate"><span class="pre">(50,</span> <span class="pre">500,</span> <span class="pre">50)</span></code>, which means we want <code class="docutils literal notranslate"><span class="pre">r</span></code> to go from 50 to 500, in jumps of 50 units at a time. Since these are specified in metres, we are saying we want the range to go from 50 to 500 metres in increments of 50 metres.</p></li>
<li><p>In the case of <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>, we take a similar approach and say we want the minimum number of points to go from 50 to 300, in steps of 50 points at a time.</p></li>
</ul>
<p>The above results in a little interactive tool that allows us to play easily and quickly with different values for the parameters and to explore how they affect the final outcome.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content/bH"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="concepts_H.html" title="previous page">Concepts</a>
    <a class='right-next' id="next-link" href="diy_H.html" title="next page">Do-It-Yourself</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Dani Arribas-Bel<br/>
        
          <div class="extra_footer">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">A course on Geographic Data Science</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://darribas.org" property="cc:attributionName" rel="cc:attributionURL">Dani Arribas-Bel</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.3da636dd464baa7582d2.js"></script>


    
    <!-- Google Analytics -->
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-6032674-1', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    <!-- End Google Analytics -->
    
  </body>
</html>